1. Compute the total of all subarray sums.

1 2 3 4 5
sum += i * (n - i + 1) * a[i];


2. ⁠Compute the total of all subsequence sums.

1 2 3
1, 2, 3, 1 2, 1 3, 2 3, 1 2 3
sum += (2 ^ (n - 1)) * a[i];


3. ⁠Compute the sum of maximum values over all subarrays.

1 2 1 1 1 1 3 2
for 4th element:
right_greater_eq[4] = 5
left_greater[4] = 2
contribution: (5 - 3 - 1) * 1

sum += (right_greater_eq[i] - left_greater[i] - 1) * a[i];


4. ⁠Compute the sum of distinct-element counts over all subarrays.

dp[i] : number of distinct elements of all subarray ending at i.
last[a[i]] : the last occurrence of a[i].
dp[i] = dp[i - 1] + i - last[a[i]];

sum = sum of dp[i] for all i(1 <= i <= n).


5. ⁠Compute the sum of bitwise OR values over all subarrays.

vector<int> first_occ(30, n + 1);
for each bit [0, 30]:
	sum += (n - first_occ[bit] + 1) * (1 << bit);



6. ⁠Compute the sum of bitwise XOR values over all subarrays.

ans = one = last_odd = 0
for each bit [0, 30]:
	for (int i = 1; i <= n; i++) {
		if (a[i] >> i & 1) {
			one++;
			if (one % 2 == 1) {
				last_odd = i;
				ans += last_odd * (1 << bit);
			}
		} else {
			if (one % 2 == 1) {
				ans += last_odd * (1 << bit);
			}
		}
	}


7. ⁠Compute the sum of XOR of all pairs.

for each bit: cnt_one * cnt_zero * (1 << bit)


8. ⁠Compute the XOR of the bitwise OR of every subarray.


vector<int> first_occ(30, n + 1);
for each bit [0, 30]:
	if ((n - first_occ[bit] + 1) % 2 == 1) ans += 1 << bit;



9. ⁠Given a tree, compute the total length of all simple paths.

down[u] : sum of all simple paths starting from child and end at u
up[u] : sum of all simple paths coming from parent and end at u

void dfs(int u, int p) {
	down[u] = 0;
	for (int v : g[u]) {
		if (v == p) continue;
		dfs(v, u);
		down[u] = down[v] + 1;
	}
}

void reroot(int u, int p) {
	for (int v : g[u]) {
		if (v == p) continue;
		up[v] = up[u] + down[u] - (down[v] + 1) + 1;
		reroot(v, u);
	}
}


10. ⁠Given two strings, find the minimum Hamming distance among all cyclic shifts of one string.

O(n ^ 2)
for (int i = 0; i < n; i++) {
	int cnt = 0;
	for (int j = 0; j < n; j++) 
		if (s[i] != s[(i + j) % n]) cnt++;
	ans = min(ans, cnt);
}




11. ⁠Compute the sum of products over all subsequences.

(1 + a)(1 + b)(1 + c)
= (1 + b + a + ab)(1 + c)
= 1 + c + b + bc + a + ac + ab + abc


12. ⁠Given an array and queries of increment on ranges (CF 276C), compute the final weighted sum after applying all increments optimally.

https://codeforces.com/contest/276/submission/221027331


13. ⁠Compute the sum of divisors for every number from 1 to N.

N log log N
for (int i = 1; i < N; i++) {
	for (int j = i; j < N; j += i) {
		sum += i;
	}
}

14. ⁠Compute the sum of absolute differences over all pairs.

Order doesn't matter. sort the array.
1 2 3 4 5
sum += (i - 1) * a[i] - pref[i - 1];


15. ⁠Given a tree, compute the sum of distinct-element counts over all simple paths.

16. ⁠Compute the sum of widths over all subsequences (width = max – min).

Order doesn't matter. sort the array.
focus on every pair (l, r).
a[l] will be min and a[r] will be max. from l to r we have 2 ^ (r - l - 1) way to chose elements.
so for a pair (l, r) ans = (a[r] - a[l]) * 2 ^ (r - l - 1)

fix r.
suppose r = 4.
(a[4] - a[3]) * power(2, 4 - 3 - 1) +
(a[4] - a[2]) * power(2, 4 - 2 - 1) +
(a[4] - a[1]) * power(2, 4 - 1 - 1)

pref[i] = pref[i - 1] + a[i] * 2 ^ (-i)
sum += a[r] * ((2 ^ (r - 1)) - 1) - pref[r - 1] * (2 ^ (r - 1));

17. ⁠Compute the total Hamming distance over all pairs.

18. ⁠Compute the sum of inversion counts over all permutations of {1 … n}.

nc2 * n! / 2

19. ⁠Compute the sum of inversion count over all binary strings with x zeros and y ones.

nc2 * (x + y - 2)! / ((x - 1)! * (y - 1)!)
